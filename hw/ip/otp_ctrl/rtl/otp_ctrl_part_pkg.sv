// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Package partition metadata.
//
// DO NOT EDIT THIS FILE DIRECTLY.
// It has been generated with
// $ ./util/design/gen-otp-mmap.py --seed 10556718629619452145
//

package otp_ctrl_part_pkg;

  import prim_util_pkg::vbits;
  import otp_ctrl_reg_pkg::*;
  import otp_ctrl_pkg::*;

  ////////////////////////////////////
  // Scrambling Constants and Types //
  ////////////////////////////////////

  parameter int NumScrmblKeys = 3;
  parameter int NumDigestSets = 4;

  parameter int ScrmblKeySelWidth = vbits(NumScrmblKeys);
  parameter int DigestSetSelWidth = vbits(NumDigestSets);
  parameter int ConstSelWidth = (ScrmblKeySelWidth > DigestSetSelWidth) ?
                                ScrmblKeySelWidth :
                                DigestSetSelWidth;

  typedef enum logic [ConstSelWidth-1:0] {
    StandardMode,
    ChainedMode
  } digest_mode_e;

  typedef logic [NumScrmblKeys-1:0][ScrmblKeyWidth-1:0] key_array_t;
  typedef logic [NumDigestSets-1:0][ScrmblKeyWidth-1:0] digest_const_array_t;
  typedef logic [NumDigestSets-1:0][ScrmblBlockWidth-1:0] digest_iv_array_t;

  typedef enum logic [ConstSelWidth-1:0] {
    Secret0Key,
    Secret1Key,
    Secret2Key
  } key_sel_e;

  typedef enum logic [ConstSelWidth-1:0] {
    CnstyDigest,
    FlashDataKey,
    FlashAddrKey,
    SramDataKey
  } digest_sel_e;

  // SEC_CM: SECRET.MEM.SCRAMBLE
  parameter key_array_t RndCnstKey = {
    128'hE3B59D91FCFA24B80990A6EA42006786,
    128'h15C1EC848743FD9D7E9E750D4A35D987,
    128'h579A31E41EA2A022044CEA9BE51E3847
  };

  // SEC_CM: PART.MEM.DIGEST
  // Note: digest set 0 is used for computing the partition digests. Constants at
  // higher indices are used to compute the scrambling keys.
  parameter digest_const_array_t RndCnstDigestConst = {
    128'hC7E66A4C1EB78F3F8B569FA392D4F18F,
    128'h7D2CF108BAF271240242CD7DA29B5768,
    128'h6A81E1393B96DAA1931285F4050FE83F,
    128'hE659995014779E34334C8699648DF237
  };

  parameter digest_iv_array_t RndCnstDigestIV = {
    64'h9367EB0C5B57E967,
    64'hFCC849CD1184A1D5,
    64'hCED5D3168B2E6FE,
    64'h7097B8D55F55C804
  };


  /////////////////////////////////////
  // Typedefs for Partition Metadata //
  /////////////////////////////////////

  typedef enum logic [1:0] {
    Unbuffered,
    Buffered,
    LifeCycle
  } part_variant_e;

  typedef struct packed {
    part_variant_e variant;
    // Offset and size within the OTP array, in Bytes.
    logic [OtpByteAddrWidth-1:0] offset;
    logic [OtpByteAddrWidth-1:0] size;
    // Key index to use for scrambling.
    key_sel_e key_sel;
    // Attributes
    logic secret;     // Whether the partition is secret (and hence scrambled)
    logic hw_digest;  // Whether the partition has a hardware digest
    logic write_lock; // Whether the partition is write lockable (via digest)
    logic read_lock;  // Whether the partition is read lockable (via digest)
    logic ecc_fatal;  // Whether the an ECC uncorrectable error leads to a fatal alert
  } part_info_t;

  parameter part_info_t PartInfoDefault = '{
      variant:    Unbuffered,
      offset:     '0,
      size:       OtpByteAddrWidth'('hFF),
      key_sel:    key_sel_e'('0),
      secret:     1'b0,
      hw_digest:  1'b0,
      write_lock: 1'b0,
      read_lock:  1'b0,
      ecc_fatal:  1'b0
  };

  ////////////////////////
  // Partition Metadata //
  ////////////////////////

  localparam part_info_t PartInfo [NumPart] = '{
    // VENDOR_TEST
    '{
      variant:    Unbuffered,
      offset:     11'd0,
      size:       64,
      key_sel:    key_sel_e'('0),
      secret:     1'b0,
      hw_digest:  1'b0,
      write_lock: 1'b1,
      read_lock:  1'b0,
      ecc_fatal:  1'b0
    },
    // CREATOR_SW_CFG
    '{
      variant:    Unbuffered,
      offset:     11'd64,
      size:       800,
      key_sel:    key_sel_e'('0),
      secret:     1'b0,
      hw_digest:  1'b0,
      write_lock: 1'b1,
      read_lock:  1'b0,
      ecc_fatal:  1'b1
    },
    // OWNER_SW_CFG
    '{
      variant:    Unbuffered,
      offset:     11'd864,
      size:       800,
      key_sel:    key_sel_e'('0),
      secret:     1'b0,
      hw_digest:  1'b0,
      write_lock: 1'b1,
      read_lock:  1'b0,
      ecc_fatal:  1'b1
    },
    // HW_CFG
    '{
      variant:    Buffered,
      offset:     11'd1664,
      size:       80,
      key_sel:    key_sel_e'('0),
      secret:     1'b0,
      hw_digest:  1'b1,
      write_lock: 1'b1,
      read_lock:  1'b0,
      ecc_fatal:  1'b1
    },
    // SECRET0
    '{
      variant:    Buffered,
      offset:     11'd1744,
      size:       40,
      key_sel:    Secret0Key,
      secret:     1'b1,
      hw_digest:  1'b1,
      write_lock: 1'b1,
      read_lock:  1'b1,
      ecc_fatal:  1'b1
    },
    // SECRET1
    '{
      variant:    Buffered,
      offset:     11'd1784,
      size:       88,
      key_sel:    Secret1Key,
      secret:     1'b1,
      hw_digest:  1'b1,
      write_lock: 1'b1,
      read_lock:  1'b1,
      ecc_fatal:  1'b1
    },
    // SECRET2
    '{
      variant:    Buffered,
      offset:     11'd1872,
      size:       88,
      key_sel:    Secret2Key,
      secret:     1'b1,
      hw_digest:  1'b1,
      write_lock: 1'b1,
      read_lock:  1'b1,
      ecc_fatal:  1'b1
    },
    // LIFE_CYCLE
    '{
      variant:    LifeCycle,
      offset:     11'd1960,
      size:       88,
      key_sel:    key_sel_e'('0),
      secret:     1'b0,
      hw_digest:  1'b0,
      write_lock: 1'b0,
      read_lock:  1'b0,
      ecc_fatal:  1'b1
    }
  };

  typedef enum {
    VendorTestIdx,
    CreatorSwCfgIdx,
    OwnerSwCfgIdx,
    HwCfgIdx,
    Secret0Idx,
    Secret1Idx,
    Secret2Idx,
    LifeCycleIdx,
    // These are not "real partitions", but in terms of implementation it is convenient to
    // add these at the end of certain arrays.
    DaiIdx,
    LciIdx,
    KdiIdx,
    // Number of agents is the last idx+1.
    NumAgentsIdx
  } part_idx_e;

  parameter int NumAgents = int'(NumAgentsIdx);

  // Breakout types for easier access of individual items.
  typedef struct packed {
    logic [63:0] hw_cfg_digest;
      logic [31:0] unallocated;
    prim_mubi_pkg::mubi8_t en_entropy_src_fw_over;
    prim_mubi_pkg::mubi8_t en_entropy_src_fw_read;
    prim_mubi_pkg::mubi8_t en_csrng_sw_app_read;
    prim_mubi_pkg::mubi8_t en_sram_ifetch;
    logic [255:0] manuf_state;
    logic [255:0] device_id;
  } otp_hw_cfg_data_t;

  // default value used for intermodule
  parameter otp_hw_cfg_data_t OTP_HW_CFG_DATA_DEFAULT = '{
    hw_cfg_digest: 64'h89165A3B3E51F2F9,
    unallocated: 32'h0,
    en_entropy_src_fw_over: prim_mubi_pkg::mubi8_t'(8'h69),
    en_entropy_src_fw_read: prim_mubi_pkg::mubi8_t'(8'h69),
    en_csrng_sw_app_read: prim_mubi_pkg::mubi8_t'(8'h69),
    en_sram_ifetch: prim_mubi_pkg::mubi8_t'(8'h69),
    manuf_state: 256'hFF79CDA72EF655A6623599922C9C67B2F1563D2C3336938848B1E59A31F6E61E,
    device_id: 256'h2B80273EE9F110E085A4FDEC926275BE366716B5D3F5588BF2F491C24DE7B90A
  };

  typedef struct packed {
    // This reuses the same encoding as the life cycle signals for indicating valid status.
    lc_ctrl_pkg::lc_tx_t valid;
    otp_hw_cfg_data_t data;
  } otp_hw_cfg_t;

  // default value for intermodule
  parameter otp_hw_cfg_t OTP_HW_CFG_DEFAULT = '{
    valid: lc_ctrl_pkg::Off,
    data: OTP_HW_CFG_DATA_DEFAULT
  };

  // OTP invalid partition default for buffered partitions.
  parameter logic [16383:0] PartInvDefault = 16384'({
    704'({
      320'h99C0629C44A58C7B0C25C41EB3DBAE9BA1F09C1F52901C2132ECF28302359F21847E00A4CBAA612C,
      384'h9DCB8131827B72DB85814B8F4ECF3A2888A837057A7AA052386544584895BD768D2570C91D370ECC6C0CD9FB928BECC8
    }),
    704'({
      64'h5F5C59B82F688335,
      256'hAEB73A5B378A187CA32EEB9A05CD25BFE2D18745B97D2A1177F8E87DAA9CE1A2,
      256'hCD77CB84D7788A14A8627D58656F737860A603207FC5220D280D63CA73763182,
      128'hAE83E6502E13A5F87B2366044032491F
    }),
    704'({
      64'h2869484ABD8E34D4,
      128'hC19F92988999D67B43C3ECCCAA62E02E,
      256'h9EB8A14FBDDCBB9BEDEEA81EA1BDACB7F84C7C1F52B7807BBD124B64AF2135BE,
      256'h31AA6FB871ABAF737B15AB8ADAC704A7473E143E64783EA8408AB58AA7E21FFD
    }),
    320'({
      64'h2E5251DDEF090596,
      128'h6A2D95A293F52F27E123D441DFC18D70,
      128'hAB3D76AE4D8D9562E08F74BAA9C25AB
    }),
    640'({
      64'h89165A3B3E51F2F9,
      32'h0, // unallocated space
      8'h69,
      8'h69,
      8'h69,
      8'h69,
      256'hFF79CDA72EF655A6623599922C9C67B2F1563D2C3336938848B1E59A31F6E61E,
      256'h2B80273EE9F110E085A4FDEC926275BE366716B5D3F5588BF2F491C24DE7B90A
    }),
    6400'({
      64'h4D8B2090B75FCC07,
      2112'h0, // unallocated space
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      512'h0,
      128'h0,
      128'h0,
      512'h0,
      2560'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0
    }),
    6400'({
      64'hCB77403F8FAFB1D7,
      4000'h0, // unallocated space
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      32'h0,
      64'h0,
      32'h0,
      64'h0,
      32'h0,
      32'h0,
      32'h0,
      1248'h0
    }),
    512'({
      64'h4BF508DBA1DD1AAD,
      448'h0
    })});

endpackage : otp_ctrl_part_pkg
